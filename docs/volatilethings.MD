## `volatile`
被`volatile`修饰的变量在读写时，会引发一些可以观测的副作用。
这些可观测的副作用由程序之外的条件引起。

### `volatile`应用
1. 并行设备的硬件寄存器(如状态寄存器)；
   表示遇到该关键字修饰的变量，无需进行优化。
2. 一个中断服务子程序访问到的变量
   ```cpp
    static int i=0;

    int main()
    {
        while(1)
        {
        if(i) dosomething();
        }
    }

    /* Interrupt service routine */
    void IRS()
    {
      i=1;
    }
   ```
   上述程序期望在中断产生时，由中断服务子程序IRS响应中断，变更程序变量i；
   使在`main`函数中调用`dosomething`函数;
   由于编译器判断在`main`函数里面没有修改过`i`，因此可能只执行一次对从`i`到某寄存器的读操作，然后每次`if`判断都只使用这个寄存器里面的“`i副本`”，导致`dosomething`永远不会被调用。
   如果将变量`i`加上`volatile`修饰，则编译器保证对变量`i`的读写操作都不会被优化，从而保证了变量`i`被外部程序更改后能及时在原程序中得到感知。

3. 多线程应用中被多个任务共享的变量
   当多线程共享同一个变量时，该变量值会被某一个线程修改，应该用`volatile`修饰。
   作用是防止编译器优化把变量从内存装入`CPU`寄存器中，当一个线程更改变量后，未及时同步到其它线程中导致程序出错。
   `volatile`的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

### 常见问题
* 一个参数可以即是`const`又是`volatile`么？
  可以。
  一个例子是只读的状态寄存器。它是`volatile`因为它可能被意想不到地改变。它是`const`因为程序不应该试图去修改它。
* 一个指针可以是`volatile`吗？为什么？
  可以。尽管这并不常见。
  一个例子是当一个中断服务子程序修该一个指向一个`buffer`的指针时。

### `volatile`的使用
* `volatile` 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素（操作系统、硬件、其它线程等）更改。所以使用` volatile` 告诉编译器不应对这样的对象进行优化。
* `volatile `关键字声明的变量，每次访问时都必须从内存中取出值（没有被` volatile `修饰的变量，可能由于编译器的优化，从` CPU `寄存器中取值）
* `const` 可以是 `volatile `（如只读的状态寄存器）
* 指针可以是 `volatile`

